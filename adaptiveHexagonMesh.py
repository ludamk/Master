# adaptiveHexagonMesh
#
############################################
######## Important: This code is not generated by Lucas Damkvist
### It is taken from: "A Concise Representation for Adaptive Hexagonal Meshes"
###                    by Luiz Henrique de Figueiredo
###
### With a few modifications made by Lucas Damkvist
############################################
#
import numpy as np
from scipy.sparse import lil_matrix
import matplotlib.pyplot as plt

import graph

# Easier access to elementer in directory
class DOTTED(dict):
	__getattr__ = dict.get
	__setattr__ = dict.__setitem__
	__delattr__ = dict.__delitem__

# Adaptive Hexagon Mesh
class adHexMesh:
    def __init__(self, L0=1, N=10, extinguishFire=1, dist=lambda p1, p2: np.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2), direction="H", theta=None):
        # Size of edge and area
        self.L0 = L0
        self.N = N
        self.extinguishFire = extinguishFire
        
        # Define function use to compute length between p1 and p2
        self.dist = dist
        
        # Define direction of mesh
        self.direction = direction
        self.theta = theta
        
        # Define parameters used in graph
        self.size = None
        self.points = None
        self.connections = None
        self.adj_matrix = None
        self.g = None
        
        # Define Faces and Queue
        self.F = {}
        self.Q = set()
        
        # Define standard hexagon
        STAR=list(range(7))
        STAR[0]=self.lattice(1,0)
        STAR[1]=self.lattice(0,1)
        STAR[2]=self.lattice(-1,1)
        STAR[3]=self.lattice(-1,0)
        STAR[4]=self.lattice(0,-1)
        STAR[5]=self.lattice(1,-1)
        STAR[6]=STAR[0]
        self.STAR = STAR

        # basic hex vertices
        VERT=list(range(6))
        for k in range(6):
        	VERT[k]=self.cartesian((0+STAR[k]+STAR[k+1])/3)
        self.VERT = VERT
        
        # basic quad vertices
        QUAD=list(range(6))
        for k in range(6):
        	QUAD[k]=[VERT[k],VERT[k]/2,VERT[k-1]/2,VERT[k-1]]
        self.QUAD = QUAD
        
        # Taking into account of numerical error
        self.roundFactor = 4
        self.error       = 0.0001
        
    def lattice(self, a,b):
    	return np.array([a,b])
    
    # Cartesian coordinates from basis u1, u2
    def cartesian(self, z):
        if self.direction == "H": # Horizontally
            u1 = np.array([3/2, np.sqrt(3)/2])
            u2 = np.array([0, np.sqrt(3)])
        elif self.direction == "V": # Vertically
            u1 = np.array([np.sqrt(3), 0])
            u2 = np.array([np.sqrt(3)/2, 3/2])
        else:
            print("Wrong direction")
    	
        # Rotate basis vectors
        if self.theta is not None:         
            R = np.array([[np.cos(self.theta), -np.sin(self.theta)], [np.sin(self.theta), np.cos(self.theta)]])

            u1 = R @ u1
            u2 = R @ u2
        
        return self.L0*(z[0]*u1 + z[1]*u2)
    
    # Convert from cartesian coordinates to lattice coordinates (basis u1, u2)
    def cartToLat(self, z):
        if self.direction == "H": # Horizontally
            u1 = np.array([3/2, np.sqrt(3)/2])
            u2 = np.array([0, np.sqrt(3)])
            
        elif self.direction == "V": # Vertically
            u1 = np.array([np.sqrt(3), 0])
            u2 = np.array([np.sqrt(3)/2, 3/2])
        else:
            print("Wrong direction")
            
        if self.theta is not None:
            R = np.array([[np.cos(self.theta), -np.sin(self.theta)], [np.sin(self.theta), np.cos(self.theta)]])
            u1 = R @ u1
            u2 = R @ u2
            
        # Basis matrix U with u1 and u2 as columns
        U = np.column_stack((u1, u2))  # Shape (2,2)
        z_scaled = np.array(z) / self.L0
    
        # Solve system
        ab = np.linalg.solve(U, z_scaled)
    
        return np.round(ab, self.roundFactor)
    
    # Key primitive: Scale and translate basic anchors
    def A(self, c,s,k):
    	return c+self.STAR[k]/(2**s)
    
    # face adjacent to quad along longest edge
    def mate(self, c):
    	t=self.F[(c[0],c[1])].t
    	s=self.F[(c[0],c[1])].s
    	return self.A(c,s+1,t)
    
    def addface(self, c,t,s):
    	if (c[0],c[1]) in self.F:
    		self.F[(c[0],c[1])].t=6
    		self.F[(c[0],c[1])].s=self.F[(c[0],c[1])].s+1
    	else:
    		self.F[(c[0],c[1])]=DOTTED({'t':t,'s':s})
    	self.Q.add((c[0],c[1]))

    def baseface(self, c):
    	self.addface(c,6,0)

    # base mesh: hexagonal grid
    def basemesh(self, rotationPoint=np.array([0,0])):
        rotationPoint_Lattice = self.cartToLat(rotationPoint)
        rotationPoint_Lattice = np.round(rotationPoint_Lattice)
        self.rotationPoint = self.cartesian(rotationPoint_Lattice)
        
        b = self.lattice(rotationPoint_Lattice[0], rotationPoint_Lattice[1])
        
        for i in range(-self.N, self.N):
            for j in range(-4*self.N, 4*self.N):
                c = b+self.lattice(0,j)
                self.baseface(c)
                c = c+self.lattice(1,0)
                self.baseface(c)
            b = b+self.lattice(2,-1)
        
        b = self.lattice(rotationPoint_Lattice[0]-1, rotationPoint_Lattice[1]+1)
        for i in range(-self.N, self.N):
            for j in range(-4*self.N-1, 4*self.N):
                c = b+self.lattice(0,j)
                self.baseface(c)
                c = c+self.lattice(-1,1)
                self.baseface(c)
            b = b+self.lattice(-2,1)

    # subdivide hex
    def subdivide(self, c):
    	s=self.F[(c[0],c[1])].s
    	for k in range(6):
    		h=self.A(c,s+1,k)
    		self.addface(h,k,s)
    	self.F[(c[0],c[1])].s=s+1

    # subdivide quad at border
    def subdivide4(self, c):
    	t=self.F[(c[0],c[1])].t
    	s=self.F[(c[0],c[1])].s
    	for j in range(2,4+1):
    		k=(t+j)%6
    		h=self.A(c,s+2,k)
    		self.addface(h,k,s+1)
    	self.F[(c[0],c[1])].s=s+1

    # Refine respecting border
    def refine(self, c):
        if self.F[(c[0],c[1])].t==6:
            self.subdivide(c)
            self.Q.add((c[0],c[1]))
        else:
            m=self.mate(c)
            if not ((m[0],m[1]) in self.F):
                self.subdivide4(c)
            else:
                self.refine(m)
                assert(self.F[(c[0],c[1])].t==6)
                self.refine(c)

    # Find points that are connected
    def findConnections(self):
        roundFactor = self.roundFactor
        connections = {}
        points = np.zeros((len(self.F)*6, 2))
        
        hexNodes = np.zeros((6,2))
        semiHexNodes = np.zeros((4,2))
        idx = -1
        
        for i, a in enumerate(self.F):
            if self.F[a].t == 6:
                idx = idx + 1
                # Center points are always "new" points in connections
                # Compute center point (cartesian) - round to insure consistency
                aCart = np.round(self.cartesian(a),roundFactor)
                points[idx,:] = aCart
                connections[(aCart[0], aCart[1])] = {'idx': idx, 'con': set()}
                
                for k in range(6):
                    v = np.round(self.vertex(a, k),roundFactor)
                    hexNodes[k,:] = v
                    
                    connections[(aCart[0], aCart[1])]['con'].add((v[0],v[1]))
                
                for k, v in enumerate(hexNodes):
                    # Add new node
                    if not (v[0], v[1]) in connections:
                        idx = idx + 1
                        points[idx,:] = v
                        connections[(v[0],v[1])] = {'idx': idx, 'con': {(aCart[0],aCart[1])}}
                    
                    # Update connections
                    connections[(v[0],v[1])]['con'].add((aCart[0], aCart[1]))
                    
                    if k == 0:
                        connections[(v[0],v[1])]['con'].add((hexNodes[1,0], hexNodes[1,1]))
                        connections[(v[0],v[1])]['con'].add((hexNodes[5,0], hexNodes[5,1]))
                    elif k == 5:
                        connections[(v[0],v[1])]['con'].add((hexNodes[0,0], hexNodes[0,1]))
                        connections[(v[0],v[1])]['con'].add((hexNodes[4,0], hexNodes[4,1]))
                    else:
                        connections[(v[0],v[1])]['con'].add((hexNodes[k-1,0], hexNodes[k-1,1]))
                        connections[(v[0],v[1])]['con'].add((hexNodes[k+1,0], hexNodes[k+1,1]))
                    
            else:
                for k in range(4):
                    v = np.round(self.vertex(a, k),roundFactor)
                    semiHexNodes[k,:] = v
                
                for k, v in enumerate(semiHexNodes):
                    # Add nodes if it is not in connections
                    if not (v[0], v[1]) in connections:
                        idx = idx + 1
                        points[idx,:] = np.array([v[0],v[1]])
                        connections[(v[0], v[1])] = {'idx': idx, 'con': set()}
                    
                    # Add connections
                    if k == 0:
                        connections[(v[0],v[1])]['con'].add((semiHexNodes[1,0], semiHexNodes[1,1]))
                        connections[(v[0],v[1])]['con'].add((semiHexNodes[3,0], semiHexNodes[3,1]))
                    elif k == 3:
                        connections[(v[0],v[1])]['con'].add((semiHexNodes[0,0], semiHexNodes[0,1]))
                        connections[(v[0],v[1])]['con'].add((semiHexNodes[2,0], semiHexNodes[2,1]))
                    else:
                        connections[(v[0],v[1])]['con'].add((semiHexNodes[k-1,0], semiHexNodes[k-1,1]))
                        connections[(v[0],v[1])]['con'].add((semiHexNodes[k+1,0], semiHexNodes[k+1,1]))

        self.points = points[:idx+1,:]
        self.connections = connections

    def generateAdjMatrix(self, ignitionPoint=None):
        l = 0
        ################# NEW
        if ignitionPoint is not None:
            points = self.points
            idx = graph.findNode(points, ignitionPoint)
            
            # Brug np.array_equal for at sammenligne arrays
            if not np.array_equal(points[idx,:], ignitionPoint):
                self.points = np.vstack([points, ignitionPoint])
                l = 1
        
        #################
        # Preallocate adj_matrix
        adj_matrix = lil_matrix((len(self.connections)+l, len(self.connections)+l))
        
        # Compute distance from p1 --> p2
        for p1 in self.connections:
             idx1 = self.connections[p1]['idx']
             
             for p2 in self.connections[p1]['con']:
                 idx2 = self.connections[p2]['idx']
                 
                 w = self.dist(np.array([p1[0],p1[1]]), np.array([p2[0],p2[1]]))
                 w = self.roundDist(w)
                 adj_matrix[idx1, idx2] = w

        ################## NEW: Add ignitionPoint to Points
        if l == 1:
            p1 = ignitionPoint
            p2 = self.points[idx,:]
            
            # p1 --> p2
            w = self.dist(np.array([p1[0],p1[1]]), np.array([p2[0],p2[1]]))
            adj_matrix[-1, idx] = w
        
            # p2 --> p1
            w = self.dist(np.array([p2[0],p2[1]]), np.array([p1[0],p1[1]]))
            adj_matrix[idx, -1] = w
                
        ##################
        self.adj_matrix = adj_matrix
        self.size = len(self.connections) + l
    
    def generateGraph(self, ignitionPoint=None):
        self.findConnections()
        self.generateAdjMatrix(ignitionPoint)
        #self.size = len(self.connections)
        
        g = graph.weightedGraph(self.size)
        g.adj_matrix = self.adj_matrix
        self.g = g
        
    #######################################################
    def generateBaseMesh(self, rotationPoint=np.array([0,0])):
        self.basemesh(rotationPoint=rotationPoint)
        
    def generateAdaptiveHexMesh(self):
        while self.Q:
            cTuple=next(iter(self.Q))
            c = np.array([cTuple[0], cTuple[1]])
            self.Q.remove((c[0],c[1]))
            if self.needsrefinement(c):
                self.refine(c)
    
    def roundDist(self, d):
        # Decimal should be a integer
        if np.floor(d) >= d-self.error:
            return np.floor(d)
        elif np.ceil(d) <= d+self.error:
            return np.ceil(d)
        else:
            return d    
    
    def needsrefinement(self, c):
        dMax = self.findMaxDistance(c)
        return dMax > self.extinguishFire

    # Find max distance in a hexagon (refine if even one edge is above limit)
    def findMaxDistance(self, c):
        dMax = 0
        
        if self.F[(c[0],c[1])].t == 6:
            # Returns max distance of the two directions c --> k and c <-- k
            for k in range(6):
                v = self.vertex(c, k)
                d = self.findDistance(self.cartesian(c), v)
                if d > dMax:
                    dMax = d
        else:
            # Computes length of edges, p0 <--> p1 <--> p2 <--> p3 <--> p0
            for k1 in range(4):
                if k1 == 3:
                    k2 = 0
                else:
                    k2 = k1+1
                v1 = self.vertex(c, k1)
                v2 = self.vertex(c, k2)
                
                d = self.findDistance(v1, v2)
                if d > dMax:
                    dMax = d
        
        return dMax

    def findDistance(self, v1, v2):
        d1 = self.roundDist(self.dist(v1, v2))
        d2 = self.roundDist(self.dist(v2, v1))
        
        if d1 > d2:
           return d1
        else:
            return d2
    
    # Face vertex
    def vertex(self, c,k):
    	t=self.F[(c[0],c[1])].t
    	s=self.F[(c[0],c[1])].s
    	if t==6:
            return self.cartesian(c)+self.VERT[k]/(2**s)
    	else:
    		return self.cartesian(c)+self.QUAD[t][k]/(2**s)-self.cartesian(self.A(0,s+1,t))
    
    def plotMesh(self, ax=None):
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(1,1,1)
        
        pCartesian = np.zeros((len(self.F), 2))
        vertexCartesian = np.zeros((len(self.F)*6, 2))
        idx = -1
        hexLines = np.zeros((7,2))
        semiHexLines = np.zeros((5,2))
        for i, p in enumerate(self.F):
            pCart = self.cartesian(p)
            pCartesian[i,:] = pCart

            ax.plot(pCart[0],pCart[1], 'bo')
            
            if self.F[p].t == 6:
                for k in range(6):
                    idx = idx + 1
                    v = self.vertex(p, k)
                    vertexCartesian[idx,:] = v
                    ax.plot(v[0],v[1], 'rx')
                    
                    hexLines[k,:] = v
                hexLines[-1,:] = hexLines[0,:]
                ax.plot(hexLines[:,0], hexLines[:,1], 'k-')
                    
            else:
                for k in range(4):
                    idx = idx + 1
                    v = self.vertex(p, k)
                    vertexCartesian[idx,:] = v
                    ax.plot(v[0], v[1], marker='o', markerfacecolor='none', markeredgecolor='green')
                    
                    semiHexLines[k,:] = v
                semiHexLines[-1,:] = semiHexLines[0,:]
                ax.plot(semiHexLines[:,0], semiHexLines[:,1], 'k-')

        ax.set_aspect('equal', adjustable='box')
        ax.grid()
    